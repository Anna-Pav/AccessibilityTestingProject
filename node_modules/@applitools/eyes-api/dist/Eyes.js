"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Eyes = void 0;
const utils = __importStar(require("@applitools/utils"));
const SessionType_1 = require("./enums/SessionType");
const EyesError_1 = require("./errors/EyesError");
const NewTestError_1 = require("./errors/NewTestError");
const DiffsFoundError_1 = require("./errors/DiffsFoundError");
const TestFailedError_1 = require("./errors/TestFailedError");
const CheckSettings_1 = require("./input/CheckSettings");
const Configuration_1 = require("./input/Configuration");
const RectangleSize_1 = require("./input/RectangleSize");
const LogHandler_1 = require("./input/LogHandler");
const MatchResult_1 = require("./output/MatchResult");
const TestResults_1 = require("./output/TestResults");
const SessionEventHandlers_1 = require("./SessionEventHandlers");
const Runners_1 = require("./Runners");
const Logger_1 = require("./Logger");
class Eyes {
    get _spec() {
        return this.constructor._spec;
    }
    static async getExecutionCloudUrl(config) {
        const client = await this._spec.makeECClient({
            settings: {
                proxy: config === null || config === void 0 ? void 0 : config.proxy,
                capabilities: { eyesServerUrl: config === null || config === void 0 ? void 0 : config.serverUrl, apiKey: config === null || config === void 0 ? void 0 : config.apiKey },
            },
        });
        return client.url;
    }
    static async setViewportSize(driver, size) {
        var _a, _b;
        await ((_b = (_a = this._spec).setViewportSize) === null || _b === void 0 ? void 0 : _b.call(_a, { target: driver, size }));
    }
    constructor(runnerOrConfig, config) {
        this._state = {};
        this._events = new Map();
        this._handlers = new SessionEventHandlers_1.SessionEventHandlers();
        if (utils.types.instanceOf(runnerOrConfig, Runners_1.EyesRunner)) {
            this._runner = runnerOrConfig;
            this._config = new Configuration_1.ConfigurationData(config, this._spec);
        }
        else {
            this._runner = new Runners_1.ClassicRunner();
            this._config = new Configuration_1.ConfigurationData(runnerOrConfig !== null && runnerOrConfig !== void 0 ? runnerOrConfig : config, this._spec);
        }
        this._runner.attach(this, this._spec);
        this._handlers.attach(this);
        this._logger = new Logger_1.Logger({ label: 'Eyes API' });
    }
    get logger() {
        return this._logger;
    }
    getLogger() {
        return this._logger;
    }
    get runner() {
        return this._runner;
    }
    getRunner() {
        return this.runner;
    }
    get driver() {
        return this._driver;
    }
    getDriver() {
        return this.driver;
    }
    get configuration() {
        return this._config;
    }
    set configuration(config) {
        this._config = new Configuration_1.ConfigurationData(config, this._spec);
    }
    getConfiguration() {
        return this._config;
    }
    setConfiguration(config) {
        this._config = new Configuration_1.ConfigurationData(config, this._spec);
    }
    get isOpen() {
        return Boolean(this._eyes);
    }
    getIsOpen() {
        return this.isOpen;
    }
    on(event, handler) {
        if (utils.types.isFunction(event))
            [handler, event] = [event, '*'];
        let handlers = this._events.get(event);
        if (!handlers) {
            handlers = new Set();
            this._events.set(event, handlers);
        }
        handlers.add(handler);
        return () => handlers.delete(handler);
    }
    off(eventOrHandler) {
        if (utils.types.isString(eventOrHandler)) {
            this._events.delete(eventOrHandler);
        }
        else {
            this._events.forEach(handlers => handlers.delete(eventOrHandler));
        }
    }
    async getExecutionCloudUrl() {
        return this.constructor.getExecutionCloudUrl(this._config);
    }
    async open(driverOrConfigOrAppName, configOrAppNameOrTestName, testNameOrViewportSize, viewportSizeOrSessionType, sessionType) {
        var _a, _b, _c, _d;
        var _e;
        if ((_b = (_a = this._spec).isDriver) === null || _b === void 0 ? void 0 : _b.call(_a, driverOrConfigOrAppName)) {
            this._driver = driverOrConfigOrAppName;
        }
        else {
            sessionType = viewportSizeOrSessionType;
            viewportSizeOrSessionType = testNameOrViewportSize;
            testNameOrViewportSize = configOrAppNameOrTestName;
            configOrAppNameOrTestName = driverOrConfigOrAppName;
        }
        if (this._config.isDisabled)
            return this._driver;
        const config = this._config.toJSON();
        if (utils.types.instanceOf(configOrAppNameOrTestName, Configuration_1.ConfigurationData)) {
            const transformedConfig = configOrAppNameOrTestName.toJSON();
            config.open = { ...config.open, ...transformedConfig.open };
            config.screenshot = { ...config.screenshot, ...transformedConfig.screenshot };
            config.check = { ...config.check, ...transformedConfig.check };
            config.close = { ...config.close, ...transformedConfig.close };
        }
        else if (utils.types.isObject(configOrAppNameOrTestName)) {
            const transformedConfig = new Configuration_1.ConfigurationData(configOrAppNameOrTestName, this._spec).toJSON();
            config.open = { ...config.open, ...transformedConfig.open };
            config.screenshot = { ...config.screenshot, ...transformedConfig.screenshot };
            config.check = { ...config.check, ...transformedConfig.check };
            config.close = { ...config.close, ...transformedConfig.close };
        }
        else if (utils.types.isString(configOrAppNameOrTestName)) {
            config.open.appName = configOrAppNameOrTestName;
        }
        if (utils.types.isString(testNameOrViewportSize))
            config.open.testName = testNameOrViewportSize;
        if (utils.types.has(viewportSizeOrSessionType, ['width', 'height'])) {
            (_c = (_e = config.open).environment) !== null && _c !== void 0 ? _c : (_e.environment = {});
            config.open.environment.viewportSize = viewportSizeOrSessionType;
        }
        if (utils.types.isEnumValue(sessionType, SessionType_1.SessionTypeEnum))
            config.open.sessionType = sessionType;
        config.open.keepPlatformNameAsIs = true;
        this._state.appName = (_d = config.open) === null || _d === void 0 ? void 0 : _d.appName;
        this._eyes = await this._runner.openEyes({
            target: this._driver,
            config,
            logger: this._logger.getLogger(),
            on: (name, data) => {
                const globalHandlers = this._events.get('*');
                if (globalHandlers)
                    globalHandlers.forEach(async (handler) => handler(name, data));
                const namedHandlers = this._events.get(name);
                if (namedHandlers)
                    namedHandlers.forEach(async (handler) => handler(data));
            },
        });
        return (this._driver &&
            new Proxy(this._driver, {
                get(target, key) {
                    if (key === 'then')
                        return;
                    return Reflect.get(target, key);
                },
            }));
    }
    async check(checkSettingsOrTargetOrName, checkSettings) {
        var _a, _b;
        var _c;
        if (this._config.isDisabled)
            return null;
        if (!this.isOpen)
            throw new EyesError_1.EyesError('Eyes not open');
        let serialized;
        if (utils.types.isString(checkSettingsOrTargetOrName)) {
            serialized = this._driver
                ? new CheckSettings_1.CheckSettingsAutomationFluent(checkSettings, this._spec)
                    .name(checkSettingsOrTargetOrName)
                    .toJSON()
                : new CheckSettings_1.CheckSettingsImageFluent(checkSettings)
                    .name(checkSettingsOrTargetOrName)
                    .toJSON();
        }
        else if (utils.types.has(checkSettingsOrTargetOrName, 'image')) {
            serialized = new CheckSettings_1.CheckSettingsImageFluent(checkSettings, checkSettingsOrTargetOrName).toJSON();
        }
        else {
            serialized = new CheckSettings_1.CheckSettingsAutomationFluent(checkSettingsOrTargetOrName, this._spec).toJSON();
        }
        const { target, settings } = serialized;
        const config = this._config.toJSON();
        // TODO remove when major version of sdk should be released
        (_a = (_c = config.screenshot).fully) !== null && _a !== void 0 ? _a : (_c.fully = false);
        let type;
        if (((_b = settings === null || settings === void 0 ? void 0 : settings.nmgOptions) === null || _b === void 0 ? void 0 : _b.nonNMGCheck) === 'addToAllDevices') {
            type = this._runner.config.type === 'ufg' ? 'classic' : 'ufg';
        }
        const [result] = await this._eyes.check({ type, target, settings, config });
        return new MatchResult_1.MatchResultData(result);
    }
    /** @deprecated */
    async checkWindow(name, timeout, fully = false) {
        return this.check({ name, timeout, fully });
    }
    /** @deprecated */
    async checkFrame(element, timeout, name) {
        return this.check({ name, frames: [element], timeout, fully: true });
    }
    /** @deprecated */
    async checkElement(element, timeout, name) {
        return this.check({ name, region: element, timeout, fully: true });
    }
    /** @deprecated */
    async checkElementBy(selector, timeout, name) {
        return this.check({ name, region: selector, timeout, fully: true });
    }
    async checkRegion(imageOrRegion, regionOrName, nameOrTimeout, ignoreMismatch = false) {
        return utils.types.has(imageOrRegion, ['x', 'y', 'width', 'height'])
            ? this.check({ region: imageOrRegion, name: regionOrName, timeout: nameOrTimeout })
            : this.check({ image: imageOrRegion }, { region: regionOrName, name: nameOrTimeout, ignoreMismatch });
    }
    /** @deprecated */
    async checkRegionByElement(element, name, timeout) {
        return this.check({ name, region: element, timeout });
    }
    /** @deprecated */
    async checkRegionBy(selector, name, timeout, fully = false) {
        return this.check({ name, region: selector, timeout, fully });
    }
    /** @deprecated */
    async checkRegionInFrame(frame, selector, timeout, name, fully = false) {
        return this.check({ name, region: selector, frames: [frame], timeout, fully });
    }
    /** @deprecated */
    async checkImage(image, name, ignoreMismatch = false) {
        return this.check({ image }, { name, ignoreMismatch });
    }
    async locate(settings) {
        if (this._config.isDisabled)
            return null;
        if (!this.isOpen)
            throw new EyesError_1.EyesError('Eyes not open');
        const config = this._config.toJSON();
        return this._spec.locate({ target: this._driver, settings: { ...this._state, ...settings }, config });
    }
    async extractTextRegions(targetOrSettings, settings) {
        if (this._config.isDisabled)
            return null;
        if (!this.isOpen)
            throw new EyesError_1.EyesError('Eyes not open');
        let target;
        if (utils.types.has(targetOrSettings, 'patterns')) {
            settings = targetOrSettings;
            if (utils.types.has(targetOrSettings, 'image')) {
                target = { image: targetOrSettings.image };
            }
            else {
                target = this._driver;
            }
        }
        else {
            target = targetOrSettings;
        }
        const config = this._config.toJSON();
        return this._spec.locateText({ target, settings: settings, config });
    }
    async extractText(targetOrSettings, settings) {
        if (this._config.isDisabled)
            return null;
        if (!this.isOpen)
            throw new EyesError_1.EyesError('Eyes not open');
        let targets;
        if (utils.types.isArray(targetOrSettings)) {
            settings = targetOrSettings;
            targets = targetOrSettings.map(settings => {
                return utils.types.has(settings, 'image') ? { image: settings.image } : this._driver;
            });
        }
        else {
            targets = Array(settings.length).fill(targetOrSettings);
        }
        settings = settings.map(settings => ({
            ...settings,
            region: utils.types.isPlainObject(settings.target) && utils.types.has(settings.target, ['left', 'top'])
                ? { ...settings.target, x: settings.target.left, y: settings.target.top }
                : settings.target,
        }));
        const config = this._config.toJSON();
        return await settings.reduce((results, settings, index) => {
            return results.then(async (results) => {
                return results.concat(await this._spec.extractText({ target: targets[index], settings: settings, config }));
            });
        }, Promise.resolve([]));
    }
    async close(throwErr = true) {
        var _a;
        if (this._config.isDisabled)
            return null;
        if (!this.isOpen)
            throw new EyesError_1.EyesError('Eyes not open');
        const deleteTest = (options) => this._spec.deleteTest({
            ...options,
            settings: {
                ...options.settings,
                serverUrl: this._config.serverUrl,
                apiKey: this._config.apiKey,
                proxy: this._config.proxy,
            },
        });
        try {
            const config = this._config.toJSON();
            await this._eyes.close({ config });
            const [result] = await this._eyes.getResults({ settings: { throwErr } });
            return new TestResults_1.TestResultsData({ result, deleteTest });
        }
        catch (err) {
            if ((_a = err.info) === null || _a === void 0 ? void 0 : _a.result) {
                const result = new TestResults_1.TestResultsData({ result: err.info.result, deleteTest });
                if (err.reason === 'test failed') {
                    throw new TestFailedError_1.TestFailedError(err.message, result);
                }
                else if (err.reason === 'test different') {
                    throw new DiffsFoundError_1.DiffsFoundError(err.message, result);
                }
                else if (err.reason === 'test new') {
                    throw new NewTestError_1.NewTestError(err.message, result);
                }
            }
            throw err;
        }
        finally {
            this._eyes = undefined;
        }
    }
    async closeAsync() {
        var _a;
        if (this._config.isDisabled)
            return null;
        const config = this._config.toJSON();
        await ((_a = this._eyes) === null || _a === void 0 ? void 0 : _a.close({ config }));
    }
    async abort() {
        if (!this.isOpen || this._config.isDisabled)
            return null;
        try {
            await this._eyes.abort();
            const [result] = await this._eyes.getResults();
            return new TestResults_1.TestResultsData({
                result,
                deleteTest: options => this._spec.deleteTest({
                    ...options,
                    settings: {
                        ...options.settings,
                        serverUrl: this._config.serverUrl,
                        apiKey: this._config.apiKey,
                        proxy: this._config.proxy,
                    },
                }),
            });
        }
        finally {
            this._eyes = undefined;
        }
    }
    async abortAsync() {
        var _a;
        if (!this.isOpen || this._config.isDisabled)
            return null;
        await ((_a = this._eyes) === null || _a === void 0 ? void 0 : _a.abort());
    }
    /** @deprecated */
    async abortIfNotClosed() {
        return this.abort();
    }
    // #region CONFIG
    async getViewportSize() {
        var _a;
        return ((_a = this._config.getViewportSize()) !== null && _a !== void 0 ? _a : (this._spec.getViewportSize
            ? new RectangleSize_1.RectangleSizeData(await this._spec.getViewportSize({ target: this._driver }))
            : undefined));
    }
    async setViewportSize(size) {
        var _a, _b;
        utils.guard.notNull(size, { name: 'size' });
        if (!this._driver) {
            this._config.setViewportSize(size);
        }
        else {
            try {
                await ((_b = (_a = this._spec).setViewportSize) === null || _b === void 0 ? void 0 : _b.call(_a, { target: this._driver, size }));
                this._config.setViewportSize(size);
            }
            catch (err) {
                if (this._spec.getViewportSize)
                    this._config.setViewportSize(await this._spec.getViewportSize({ target: this._driver }));
                throw new EyesError_1.EyesError('Failed to set the viewport size');
            }
        }
    }
    getScrollRootElement() {
        return this._config.getScrollRootElement();
    }
    setScrollRootElement(scrollRootElement) {
        this._config.setScrollRootElement(scrollRootElement);
    }
    setLogHandler(handler) {
        this._logger.setLogHandler(handler);
    }
    getLogHandler() {
        const handler = this._logger.getLogHandler();
        if (handler) {
            if (!utils.types.has(handler, 'type')) {
                return handler;
            }
            else if (handler.type === 'file') {
                return new LogHandler_1.FileLogHandlerData(true, handler.filename, handler.append);
            }
            else if (handler.type === 'console') {
                return new LogHandler_1.ConsoleLogHandlerData(true);
            }
        }
        return new LogHandler_1.NullLogHandlerData();
    }
    setCutProvider(cutProvider) {
        this._config.setCut(cutProvider);
    }
    setImageCut(cutProvider) {
        this.setCutProvider(cutProvider);
    }
    getIsCutProviderExplicitlySet() {
        return Boolean(this._config.getCut());
    }
    getRotation() {
        return this._config.getRotation();
    }
    setRotation(rotation) {
        this._config.setRotation(rotation);
    }
    getScaleRatio() {
        return this._config.getScaleRatio();
    }
    setScaleRatio(scaleRatio) {
        this._config.setScaleRatio(scaleRatio);
    }
    getSaveDebugScreenshots() {
        return this._config.getSaveDebugScreenshots();
    }
    setSaveDebugScreenshots(save) {
        this._config.setSaveDebugScreenshots(save);
    }
    getDebugScreenshotsPath() {
        return this._config.getDebugScreenshotsPath();
    }
    setDebugScreenshotsPath(path) {
        this._config.setDebugScreenshotsPath(path);
    }
    getDebugScreenshotsPrefix() {
        return this._config.getDebugScreenshotsPrefix();
    }
    setDebugScreenshotsPrefix(prefix) {
        this._config.setDebugScreenshotsPrefix(prefix);
    }
    addProperty(name, value) {
        return this._config.addProperty(name, value);
    }
    clearProperties() {
        return this._config.setProperties([]);
    }
    getBatch() {
        return this._config.getBatch();
    }
    setBatch(batchOrName, id, startedAt) {
        if (utils.types.isString(batchOrName)) {
            this._config.setBatch({ name: batchOrName, id, startedAt: new Date(startedAt) });
        }
        else {
            this._config.setBatch(batchOrName);
        }
    }
    getApiKey() {
        return this._config.getApiKey();
    }
    setApiKey(apiKey) {
        this._config.setApiKey(apiKey);
    }
    getTestName() {
        return this._config.getTestName();
    }
    setTestName(testName) {
        this._config.setTestName(testName);
    }
    getAppName() {
        return this._config.getAppName();
    }
    setAppName(appName) {
        this._config.setAppName(appName);
    }
    getBaselineBranchName() {
        return this._config.getBaselineBranchName();
    }
    setBaselineBranchName(baselineBranchName) {
        this._config.setBaselineBranchName(baselineBranchName);
    }
    /** @deprecated */
    getBaselineName() {
        return this.getBaselineEnvName();
    }
    /** @deprecated */
    setBaselineName(baselineName) {
        this.setBaselineEnvName(baselineName);
    }
    getBaselineEnvName() {
        return this._config.getBaselineEnvName();
    }
    setBaselineEnvName(baselineEnvName) {
        this._config.setBaselineEnvName(baselineEnvName);
    }
    getBranchName() {
        return this._config.getBranchName();
    }
    setBranchName(branchName) {
        this._config.setBranchName(branchName);
    }
    getHostApp() {
        return this._config.getHostApp();
    }
    setHostApp(hostApp) {
        this._config.setHostApp(hostApp);
    }
    getHostOS() {
        return this._config.getHostOS();
    }
    setHostOS(hostOS) {
        this._config.setHostOS(hostOS);
    }
    getHostAppInfo() {
        return this._config.getHostAppInfo();
    }
    setHostAppInfo(hostAppInfo) {
        this._config.setHostAppInfo(hostAppInfo);
    }
    getHostOSInfo() {
        return this._config.getHostOSInfo();
    }
    setHostOSInfo(hostOSInfo) {
        this._config.setHostOSInfo(hostOSInfo);
    }
    getDeviceInfo() {
        return this._config.getDeviceInfo();
    }
    setDeviceInfo(deviceInfo) {
        this._config.setDeviceInfo(deviceInfo);
    }
    setIgnoreCaret(ignoreCaret) {
        this._config.setIgnoreCaret(ignoreCaret);
    }
    getIgnoreCaret() {
        return this._config.getIgnoreCaret();
    }
    getIsDisabled() {
        return this._config.getIsDisabled();
    }
    setIsDisabled(isDisabled) {
        this._config.setIsDisabled(isDisabled);
    }
    getMatchLevel() {
        return this._config.getMatchLevel();
    }
    setMatchLevel(matchLevel) {
        this._config.setMatchLevel(matchLevel);
    }
    getMatchTimeout() {
        return this._config.getMatchTimeout();
    }
    setMatchTimeout(matchTimeout) {
        this._config.setMatchTimeout(matchTimeout);
    }
    getParentBranchName() {
        return this._config.getParentBranchName();
    }
    setParentBranchName(parentBranchName) {
        this._config.setParentBranchName(parentBranchName);
    }
    setProxy(proxyOrUrlOrIsDisabled, username, password, isHttpOnly) {
        this._config.setProxy(proxyOrUrlOrIsDisabled, username, password, isHttpOnly);
        return this;
    }
    getProxy() {
        return this._config.getProxy();
    }
    getSaveDiffs() {
        return this._config.saveDiffs;
    }
    setSaveDiffs(saveDiffs) {
        this._config.saveDiffs = saveDiffs;
    }
    getSaveNewTests() {
        return this._config.saveNewTests;
    }
    setSaveNewTests(saveNewTests) {
        this._config.saveNewTests = saveNewTests;
    }
    getServerUrl() {
        return this._config.getServerUrl();
    }
    setServerUrl(serverUrl) {
        this._config.setServerUrl(serverUrl);
    }
    getSendDom() {
        return this._config.getSendDom();
    }
    setSendDom(sendDom) {
        this._config.setSendDom(sendDom);
    }
    getHideCaret() {
        return this._config.getHideCaret();
    }
    setHideCaret(hideCaret) {
        this._config.setHideCaret(hideCaret);
    }
    getHideScrollbars() {
        return this._config.getHideScrollbars();
    }
    setHideScrollbars(hideScrollbars) {
        this._config.setHideScrollbars(hideScrollbars);
    }
    getForceFullPageScreenshot() {
        return this._config.getForceFullPageScreenshot();
    }
    setForceFullPageScreenshot(forceFullPageScreenshot) {
        this._config.setForceFullPageScreenshot(forceFullPageScreenshot);
    }
    getWaitBeforeScreenshots() {
        return this._config.getWaitBeforeScreenshots();
    }
    setWaitBeforeScreenshots(waitBeforeScreenshots) {
        this._config.setWaitBeforeScreenshots(waitBeforeScreenshots);
    }
    getStitchMode() {
        return this._config.getStitchMode();
    }
    setStitchMode(stitchMode) {
        this._config.setStitchMode(stitchMode);
    }
    getStitchOverlap() {
        return this._config.getStitchOverlap();
    }
    setStitchOverlap(stitchOverlap) {
        this._config.setStitchOverlap(stitchOverlap);
    }
    /**
     * @undocumented
     * @deprecated
     */
    getSessionEventHandlers() {
        return this._handlers;
    }
    /**
     * @undocumented
     * @deprecated
     */
    addSessionEventHandler(handler) {
        this._handlers.addEventHandler(handler);
    }
    /**
     * @undocumented
     * @deprecated
     */
    removeSessionEventHandler(handler) {
        this._handlers.removeEventHandler(handler);
    }
    /**
     * @undocumented
     * @deprecated
     */
    clearSessionEventHandlers() {
        return this._handlers.clearEventHandlers();
    }
}
exports.Eyes = Eyes;
