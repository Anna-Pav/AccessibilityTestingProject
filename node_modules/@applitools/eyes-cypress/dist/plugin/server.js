"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const webSocket_1 = __importDefault(require("./webSocket"));
const core_1 = require("@applitools/core");
const handleTestResults_1 = __importDefault(require("./handleTestResults"));
const path_1 = __importDefault(require("path"));
const fs_1 = __importDefault(require("fs"));
const semver_1 = require("semver");
const https_1 = require("https");
const ws_1 = require("ws");
const which_1 = __importDefault(require("which"));
const util_1 = require("util");
function makeStartServer({ logger, eyesConfig }) {
    return async function startServer(options) {
        const key = fs_1.default.readFileSync(path_1.default.resolve(__dirname, '../../src/pem/server.key'));
        const cert = fs_1.default.readFileSync(path_1.default.resolve(__dirname, '../../src/pem/server.cert'));
        const https = new https_1.Server({
            key,
            cert,
        });
        await (0, util_1.promisify)(https.listen.bind(https))();
        const port = https.address().port;
        const wss = new ws_1.Server({ server: https, path: '/eyes', maxPayload: 254 * 1024 * 1024 });
        wss.on('close', () => https.close());
        const forkOptions = {
            detached: true,
        };
        const cypressVersion = require('cypress/package.json').version;
        const isCypressVersionBelow7 = (0, semver_1.lt)(cypressVersion, '7.0.0');
        const isNodeVersionSystem = !!(options === null || options === void 0 ? void 0 : options.nodeVersion) && options.nodeVersion !== 'system';
        if (isCypressVersionBelow7 || isNodeVersionSystem) {
            forkOptions.execPath = await (0, which_1.default)('node');
        }
        const { port: universalPort, close: closeUniversalServer } = await (0, core_1.makeCoreServerProcess)({
            idleTimeout: 0,
            shutdownMode: 'stdin',
            forkOptions,
            singleton: false,
            portResolutionMode: 'random',
            debug: eyesConfig.universalDebug,
        });
        const managers = [];
        let socketWithUniversal;
        wss.on('connection', socketWithClient => {
            socketWithUniversal = (0, webSocket_1.default)(`ws://localhost:${universalPort}/eyes`);
            socketWithUniversal.setPassthroughListener((message) => {
                logger.log('<== ', message.toString().slice(0, 1000));
                const { name, payload } = JSON.parse(message);
                if (name === 'Core.makeManager') {
                    managers.push({ manager: payload.result, socketWithUniversal });
                }
                socketWithClient.send(message.toString());
            });
            socketWithClient.on('message', (message) => {
                const msg = JSON.parse(message);
                logger.log('==> ', message.toString().slice(0, 1000));
                if (msg.name === 'Core.makeSDK') {
                    const newMessage = Buffer.from(JSON.stringify({
                        name: msg.name,
                        key: msg.key,
                        payload: Object.assign(msg.payload, { cwd: process.cwd() }),
                    }), 'utf-8');
                    socketWithUniversal.send(newMessage);
                }
                else if (msg.name === 'Test.printTestResults') {
                    try {
                        if (msg.payload.resultConfig.tapDirPath && msg.payload.resultConfig.shouldCreateTapFile) {
                            handleTestResults_1.default.handleBatchResultsFile(msg.payload.testResults, {
                                tapFileName: msg.payload.resultConfig.tapFileName,
                                tapDirPath: msg.payload.resultConfig.tapDirPath,
                            });
                        }
                        handleTestResults_1.default.printTestResults({
                            testResults: msg.payload.testResults,
                            resultConfig: msg.payload.resultConfig,
                        });
                        socketWithClient.send(JSON.stringify({
                            name: 'Test.printTestResults',
                            key: msg.key,
                            payload: { result: 'success' },
                        }));
                    }
                    catch (ex) {
                        socketWithClient.send(JSON.stringify({
                            name: 'Test.printTestResults',
                            key: msg.key,
                            payload: { result: ex.message.toString() },
                        }));
                    }
                }
                else {
                    socketWithUniversal.send(message);
                }
            });
        });
        return {
            server: wss,
            port,
            closeManager,
            closeBatches,
            closeUniversalServer,
        };
        function closeManager() {
            return Promise.all(managers.map(({ manager, socketWithUniversal }) => socketWithUniversal.request('EyesManager.getResults', {
                manager,
                settings: { throwErr: false, removeDuplicateTests: eyesConfig.eyesRemoveDuplicateTests },
            })));
        }
        function closeBatches(settings) {
            if (socketWithUniversal)
                return socketWithUniversal.request('Core.closeBatch', { settings }).catch((err) => {
                    logger.log('@@@', err);
                });
        }
    };
}
exports.default = makeStartServer;
