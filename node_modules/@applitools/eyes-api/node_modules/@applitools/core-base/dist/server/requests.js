"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.makeEyesRequests = exports.makeCoreRequests = void 0;
const logger_1 = require("@applitools/logger");
const req_eyes_1 = require("./req-eyes");
const upload_1 = require("./upload");
const utils = __importStar(require("@applitools/utils"));
function makeCoreRequests({ agentId: defaultAgentId, fetch, logger, }) {
    var _a;
    const defaultLogger = (_a = logger === null || logger === void 0 ? void 0 : logger.extend({ label: 'core-requests' })) !== null && _a !== void 0 ? _a : (0, logger_1.makeLogger)({ label: 'core-requests' });
    const getAccountInfoWithCache = utils.general.cachify(getAccountInfo, ([{ settings }]) => {
        return [settings.serverUrl, settings.apiKey, settings.proxy];
    });
    const getBatchBranchesWithCache = utils.general.cachify(getBatchBranches, ([{ settings }]) => {
        return [settings.serverUrl, settings.apiKey, settings.proxy, settings.batchId];
    });
    return {
        getAccountInfo: getAccountInfoWithCache,
        getBatchBranches: getBatchBranchesWithCache,
        openEyes,
        locate,
        locateText,
        extractText,
        closeBatch,
        deleteTest,
        logEvent,
    };
    async function openEyes({ settings, logger = defaultLogger, }) {
        var _a, _b, _c;
        const agentId = `${defaultAgentId} ${settings.agentId ? `[${settings.agentId}]` : ''}`.trim();
        const req = (0, req_eyes_1.makeReqEyes)({ config: { ...settings, agentId }, fetch, logger });
        logger.log('Request "openEyes" called with settings', settings);
        const accountPromise = getAccountInfoWithCache({ settings });
        const response = await req('/api/sessions/running', {
            name: 'openEyes',
            method: 'POST',
            body: {
                startInfo: {
                    agentId,
                    agentSessionId: settings.userTestId,
                    agentRunId: settings.userTestId,
                    sessionType: settings.sessionType,
                    appIdOrName: settings.appName,
                    scenarioIdOrName: settings.testName,
                    displayName: settings.displayName,
                    properties: settings.properties,
                    batchInfo: settings.batch && {
                        id: settings.batch.id,
                        name: settings.batch.name,
                        batchSequenceName: settings.batch.sequenceName,
                        startedAt: settings.batch.startedAt,
                        notifyOnCompletion: settings.batch.notifyOnCompletion,
                        properties: settings.batch.properties,
                    },
                    egSessionId: (_b = (_a = settings.environment) === null || _a === void 0 ? void 0 : _a.ecSessionId) !== null && _b !== void 0 ? _b : null,
                    environment: settings.environment &&
                        ((_c = settings.environment.rawEnvironment) !== null && _c !== void 0 ? _c : {
                            os: settings.environment.os,
                            osInfo: settings.environment.osInfo,
                            hostingApp: settings.environment.hostingApp,
                            hostingAppInfo: settings.environment.hostingAppInfo,
                            deviceInfo: settings.environment.deviceName,
                            displaySize: settings.environment.viewportSize && utils.geometry.round(settings.environment.viewportSize),
                            inferred: settings.environment.userAgent && `useragent:${settings.environment.userAgent}`,
                        }),
                    environmentName: settings.environmentName,
                    baselineEnvName: settings.baselineEnvName,
                    branchName: settings.branchName,
                    parentBranchName: settings.parentBranchName,
                    baselineBranchName: settings.baselineBranchName,
                    compareWithParentBranch: settings.compareWithParentBranch,
                    parentBranchBaselineSavedBefore: settings.gitBranchingTimestamp,
                    ignoreBaseline: settings.ignoreBaseline,
                    saveDiffs: settings.saveDiffs,
                    timeout: settings.abortIdleTestTimeout,
                },
            },
            expected: [200, 201],
            logger,
        });
        const test = await response.json().then(async (result) => {
            var _a, _b, _c, _d, _e, _f;
            const test = {
                testId: result.id,
                userTestId: settings.userTestId,
                batchId: (_b = (_a = settings.batch) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : result.batchId,
                baselineId: result.baselineId,
                sessionId: result.sessionId,
                resultsUrl: result.url,
                appId: settings.appName,
                isNew: (_c = result.isNew) !== null && _c !== void 0 ? _c : response.status === 201,
                keepBatchOpen: (_d = settings.keepBatchOpen) !== null && _d !== void 0 ? _d : false,
                server: { serverUrl: settings.serverUrl, apiKey: settings.apiKey, proxy: settings.proxy },
                rendererId: (_e = settings.environment) === null || _e === void 0 ? void 0 : _e.rendererId,
                rendererInfo: (_f = settings.environment) === null || _f === void 0 ? void 0 : _f.rendererInfo,
            };
            if (result.renderingInfo) {
                const { serviceUrl, accessToken, resultsUrl, ...rest } = result.renderingInfo;
                test.account = { ufg: { serverUrl: serviceUrl, accessToken }, uploadUrl: resultsUrl, ...rest };
            }
            else {
                test.account = await accountPromise;
            }
            return test;
        });
        logger.log('Request "openEyes" finished successfully with body', test);
        const upload = (0, upload_1.makeUpload)({ config: { uploadUrl: test.account.uploadUrl, proxy: settings.proxy }, logger });
        return makeEyesRequests({ test, req, upload, logger });
    }
    async function locate({ target, settings, logger = defaultLogger, }) {
        const agentId = `${defaultAgentId} ${settings.agentId ? `[${settings.agentId}]` : ''}`.trim();
        const req = (0, req_eyes_1.makeReqEyes)({ config: { ...settings, agentId }, fetch, logger });
        logger.log('Request "locate" called for target', target, 'with settings', settings);
        const account = await getAccountInfoWithCache({ settings });
        const upload = (0, upload_1.makeUpload)({ config: { uploadUrl: account.uploadUrl, proxy: settings.proxy }, logger });
        target.image = await upload({ name: 'image', resource: target.image });
        const response = await req('/api/locators/locate', {
            name: 'locate',
            method: 'POST',
            body: {
                imageUrl: target.image,
                appName: settings.appName,
                locatorNames: settings.locatorNames,
                firstOnly: settings.firstOnly,
            },
            expected: 200,
            logger,
        });
        const result = await response.json();
        logger.log('Request "locate" finished successfully with body', result);
        return result;
    }
    async function locateText({ target, settings, logger = defaultLogger, }) {
        const agentId = `${defaultAgentId} ${settings.agentId ? `[${settings.agentId}]` : ''}`.trim();
        const req = (0, req_eyes_1.makeReqEyes)({ config: { ...settings, agentId }, fetch, logger });
        logger.log('Request "locateText" called for target', target, 'with settings', settings);
        const account = await getAccountInfoWithCache({ settings });
        const upload = (0, upload_1.makeUpload)({ config: { uploadUrl: account.uploadUrl, proxy: settings.proxy }, logger });
        [target.image, target.dom] = await Promise.all([
            upload({ name: 'image', resource: target.image }),
            target.dom && upload({ name: 'dom', resource: target.dom, gzip: true }),
        ]);
        const response = await req('/api/sessions/running/images/textregions', {
            name: 'locateText',
            method: 'POST',
            body: {
                appOutput: {
                    screenshotUrl: target.image,
                    domUrl: target.dom,
                    location: target.locationInViewport && utils.geometry.round(target.locationInViewport),
                },
                patterns: settings.patterns,
                ignoreCase: settings.ignoreCase,
                firstOnly: settings.firstOnly,
                language: settings.language,
            },
            expected: 200,
            logger,
        });
        const result = await response.json();
        logger.log('Request "locateText" finished successfully with body', result);
        return result;
    }
    async function extractText({ target, settings, logger = defaultLogger, }) {
        const agentId = `${defaultAgentId} ${settings.agentId ? `[${settings.agentId}]` : ''}`.trim();
        const req = (0, req_eyes_1.makeReqEyes)({ config: { ...settings, agentId }, fetch, logger });
        logger.log('Request "extractText" called for target', target, 'with settings', settings);
        const account = await getAccountInfoWithCache({ settings });
        const upload = (0, upload_1.makeUpload)({ config: { uploadUrl: account.uploadUrl, proxy: settings.proxy }, logger });
        [target.image, target.dom] = await Promise.all([
            upload({ name: 'image', resource: target.image }),
            target.dom && upload({ name: 'dom', resource: target.dom, gzip: true }),
        ]);
        const response = await req('/api/sessions/running/images/text', {
            name: 'extractText',
            method: 'POST',
            body: {
                appOutput: {
                    screenshotUrl: target.image,
                    domUrl: target.dom,
                    location: target.locationInViewport && utils.geometry.round(target.locationInViewport),
                },
                regions: target.size && [{ left: 0, top: 0, ...utils.geometry.round(target.size), expected: settings.hint }],
                minMatch: settings.minMatch,
                language: settings.language,
            },
            expected: 200,
            logger,
        });
        const result = await response.json();
        logger.log('Request "extractText" finished successfully with body', result);
        return result;
    }
    async function getAccountInfo({ settings, logger = defaultLogger, }) {
        const agentId = `${defaultAgentId} ${settings.agentId ? `[${settings.agentId}]` : ''}`.trim();
        const req = (0, req_eyes_1.makeReqEyes)({ config: { ...settings, agentId }, fetch, logger });
        logger.log('Request "getAccountInfo" called with settings', settings);
        const response = await req('/api/sessions/renderinfo', {
            name: 'getAccountInfo',
            method: 'GET',
            expected: 200,
            logger,
        });
        const result = await response.json().then(result => {
            const { serviceUrl, accessToken, resultsUrl, ...rest } = result;
            return { ufg: { serverUrl: serviceUrl, accessToken }, uploadUrl: resultsUrl, ...rest };
        });
        logger.log('Request "getAccountInfo" finished successfully with body', result);
        return result;
    }
    async function getBatchBranches({ settings, logger = defaultLogger, }) {
        const agentId = `${defaultAgentId} ${settings.agentId ? `[${settings.agentId}]` : ''}`.trim();
        const req = (0, req_eyes_1.makeReqEyes)({ config: { ...settings, agentId }, fetch, logger });
        logger.log('Request "getBatchBranches" called with settings', settings);
        const response = await req(`/api/sessions/batches/${settings.batchId}/config/bypointerId`, {
            name: 'getBatchBranches',
            method: 'GET',
            logger,
        });
        const result = response.status === 200
            ? await response.json().then(result => {
                return { branchName: result.scmSourceBranch, parentBranchName: result.scmTargetBranch };
            })
            : { branchName: undefined, parentBranchName: undefined };
        logger.log('Request "getBatchBranches" finished successfully with body', result);
        return result;
    }
    async function closeBatch({ settings, logger = defaultLogger }) {
        const agentId = `${defaultAgentId} ${settings.agentId ? `[${settings.agentId}]` : ''}`.trim();
        const req = (0, req_eyes_1.makeReqEyes)({ config: { ...settings, agentId }, fetch, logger });
        logger.log('Request "closeBatch" called with settings', settings);
        await req(`/api/sessions/batches/${settings.batchId}/close/bypointerId`, {
            name: 'closeBatch',
            method: 'DELETE',
            expected: 200,
            logger,
        });
        logger.log('Request "closeBatch" finished successfully');
    }
    async function deleteTest({ settings, logger = defaultLogger }) {
        const agentId = `${defaultAgentId} ${settings.agentId ? `[${settings.agentId}]` : ''}`.trim();
        const req = (0, req_eyes_1.makeReqEyes)({ config: { ...settings, agentId }, fetch, logger });
        logger.log('Request "deleteTest" called with settings', settings);
        await req(`/api/sessions/batches/${settings.batchId}/${settings.testId}`, {
            name: 'deleteTest',
            method: 'DELETE',
            query: {
                accessToken: settings.secretToken,
            },
            expected: 200,
            logger,
        });
        logger.log('Request "deleteTest" finished successfully');
    }
    async function logEvent({ settings, logger = defaultLogger, }) {
        settings = utils.types.isArray(settings) ? settings : [settings];
        const [config] = settings;
        const agentId = `${defaultAgentId} ${config.agentId ? `[${config.agentId}]` : ''}`.trim();
        const req = (0, req_eyes_1.makeReqEyes)({ config: { ...config, agentId }, fetch, logger });
        logger.log('Request "logEvent" called with settings', settings);
        await req(`/api/sessions/log`, {
            name: 'logEvent',
            method: 'POST',
            body: {
                events: settings.map(settings => {
                    var _a, _b;
                    return {
                        event: settings.event,
                        level: (_a = settings.level) !== null && _a !== void 0 ? _a : 'Info',
                        timestamp: (_b = settings.timestamp) !== null && _b !== void 0 ? _b : new Date().toISOString(),
                    };
                }),
            },
            expected: 200,
            logger,
        });
        logger.log('Request "logEvent" finished successfully');
    }
}
exports.makeCoreRequests = makeCoreRequests;
function makeEyesRequests({ test, req, upload, logger: defaultLogger, }) {
    let resultsPromise = undefined;
    let supportsCheckAndClose = true;
    return {
        test,
        get running() {
            return !resultsPromise;
        },
        check,
        checkAndClose,
        report,
        close,
        abort,
        getResults,
    };
    async function check({ target, settings, logger = defaultLogger, }) {
        logger.log('Request "check" called for target', target, 'with settings', settings);
        [target.image, target.dom] = await Promise.all([
            upload({ name: 'image', resource: target.image }),
            target.dom && upload({ name: 'dom', resource: target.dom, gzip: true }),
        ]);
        const response = await req(`/api/sessions/running/${encodeURIComponent(test.testId)}`, {
            name: 'check',
            method: 'POST',
            body: transformCheckOptions({ target, settings }),
            expected: 200,
            logger,
        });
        const result = await response.json();
        result.userTestId = test.userTestId;
        logger.log('Request "check" finished successfully with body', result);
        return [result];
    }
    async function checkAndClose({ target, settings, logger = defaultLogger, }) {
        if (!supportsCheckAndClose) {
            logger.log('Request "checkAndClose" is notSupported by the server, using "check" and "close" requests instead');
            await check({ target, settings, logger });
            await close({ settings, logger });
            return getResults({ settings, logger });
        }
        logger.log('Request "checkAndClose" called for target', target, 'with settings', settings);
        [target.image, target.dom] = await Promise.all([
            upload({ name: 'image', resource: target.image }),
            target.dom && upload({ name: 'dom', resource: target.dom, gzip: true }),
        ]);
        const matchOptions = transformCheckOptions({ target, settings });
        resultsPromise = req(`/api/sessions/running/${encodeURIComponent(test.testId)}/matchandend`, {
            name: 'checkAndClose',
            method: 'POST',
            body: {
                ...matchOptions,
                options: {
                    ...matchOptions.options,
                    removeSession: false,
                    removeSessionIfMatching: settings.ignoreMismatch,
                    updateBaselineIfNew: settings.updateBaselineIfNew,
                    updateBaselineIfDifferent: settings.updateBaselineIfDifferent,
                },
            },
            query: {
                updateBaseline: test.isNew ? settings === null || settings === void 0 ? void 0 : settings.updateBaselineIfNew : settings === null || settings === void 0 ? void 0 : settings.updateBaselineIfDifferent,
            },
            hooks: {
                beforeRetry({ response, stop }) {
                    if ((response === null || response === void 0 ? void 0 : response.status) === 404)
                        return stop;
                },
            },
            expected: 200,
            logger,
        }).then(async (response) => {
            if (response.status === 404) {
                supportsCheckAndClose = false;
                return checkAndClose({ target, settings });
            }
            const result = await response.json();
            result.userTestId = test.userTestId;
            logger.log('Request "checkAndClose" finished successfully with body', result);
            return [result];
        });
        return resultsPromise;
    }
    async function close({ settings, logger = defaultLogger, } = {}) {
        logger.log(`Request "close" called for test ${test.testId} with settings`, settings);
        if (resultsPromise) {
            logger.log(`Request "close" called for test ${test.testId} that was already stopped`);
            return;
        }
        resultsPromise = report({ settings, logger })
            .then(() => req(`/api/sessions/running/${encodeURIComponent(test.testId)}`, {
            name: 'close',
            method: 'DELETE',
            query: {
                aborted: false,
                updateBaseline: test.isNew ? settings === null || settings === void 0 ? void 0 : settings.updateBaselineIfNew : settings === null || settings === void 0 ? void 0 : settings.updateBaselineIfDifferent,
            },
            expected: 200,
            logger,
        }))
            .then(async (response) => {
            var _a;
            const result = await response.json();
            result.userTestId = test.userTestId;
            result.url = test.resultsUrl;
            result.isNew = test.isNew;
            // for backwards compatibility with outdated servers
            (_a = result.status) !== null && _a !== void 0 ? _a : (result.status = result.missing === 0 && result.mismatches === 0 ? 'Passed' : 'Unresolved');
            logger.log('Request "close" finished successfully with body', result);
            return [result];
        });
    }
    async function abort({ settings, logger = defaultLogger, } = {}) {
        logger.log(`Request "abort" called for test ${test.testId} with settings`, settings);
        if (resultsPromise) {
            logger.log(`Request "abort" called for test ${test.testId} that was already stopped`);
            return;
        }
        resultsPromise = report({ settings, logger })
            .then(() => req(`/api/sessions/running/${encodeURIComponent(test.testId)}`, {
            name: 'abort',
            method: 'DELETE',
            query: {
                aborted: true,
            },
            expected: 200,
            logger,
        }))
            .then(async (response) => {
            const result = await response.json();
            result.userTestId = test.userTestId;
            logger.log('Request "abort" finished successfully with body', result);
            return [result];
        });
    }
    async function getResults({ settings, logger = defaultLogger, } = {}) {
        logger.log(`Request "getResults" called for test ${test.testId} with settings`, settings);
        if (!resultsPromise) {
            logger.warn(`The test with id "${test.testId}" is going to be auto aborted`);
            await abort({ settings, logger });
        }
        const results = await resultsPromise;
        logger.log('Request "getResults" finished successfully with body', results);
        return results;
    }
    async function report({ settings, logger = defaultLogger, }) {
        logger.log(`Request "report" called for test ${test.testId} with settings`, settings);
        if (!(settings === null || settings === void 0 ? void 0 : settings.testMetadata) || utils.types.isEmpty(settings.testMetadata))
            return;
        try {
            await req(`/api/sessions/running/${encodeURIComponent(test.testId)}/selfhealdata`, {
                name: 'reportSelfHealing',
                method: 'PUT',
                body: {
                    operations: settings.testMetadata.map(item => {
                        return { old: item === null || item === void 0 ? void 0 : item.originalSelector, new: item === null || item === void 0 ? void 0 : item.successfulSelector, timestamp: new Date().toISOString() };
                    }),
                },
                expected: 200,
                logger,
            });
        }
        catch (error) {
            logger.warn(error);
        }
    }
}
exports.makeEyesRequests = makeEyesRequests;
function transformCheckOptions({ target, settings }) {
    var _a, _b;
    return {
        appOutput: {
            title: target.name,
            screenshotUrl: target.image,
            domUrl: target.dom,
            location: target.locationInViewport && utils.geometry.round(target.locationInViewport),
            pageCoverageInfo: settings.pageId && {
                pageId: settings.pageId,
                imagePositionInPage: target.locationInView && utils.geometry.round(target.locationInView),
                ...(target.fullViewSize && utils.geometry.round(target.fullViewSize)),
            },
        },
        options: {
            imageMatchSettings: {
                ignore: transformRegions({ regions: settings.ignoreRegions }),
                layout: transformRegions({ regions: settings.layoutRegions }),
                strict: transformRegions({ regions: settings.strictRegions }),
                content: transformRegions({ regions: settings.contentRegions }),
                floating: transformRegions({ regions: settings.floatingRegions }),
                accessibility: transformRegions({ regions: settings.accessibilityRegions }),
                accessibilitySettings: settings.accessibilitySettings,
                ignoreDisplacements: settings.ignoreDisplacements,
                ignoreCaret: settings.ignoreCaret,
                enablePatterns: settings.enablePatterns,
                matchLevel: (_a = settings.matchLevel) !== null && _a !== void 0 ? _a : 'Strict',
                useDom: (_b = settings.useDom) !== null && _b !== void 0 ? _b : false,
                densityMetrics: settings.densityMetrics,
            },
            name: settings.name,
            source: target.source,
            renderId: settings.renderId,
            variantId: settings.userCommandId,
            ignoreMismatch: settings.ignoreMismatch,
            ignoreMatch: settings.ignoreMatch,
            forceMismatch: settings.forceMismatch,
            forceMatch: settings.forceMatch,
        },
    };
}
function transformRegions({ regions, }) {
    return regions === null || regions === void 0 ? void 0 : regions.map(region => {
        var _a;
        const options = {};
        if (utils.types.has(region, 'region')) {
            options.regionId = region.regionId;
            if (utils.types.has(region, 'type')) {
                options.type = region.type;
            }
            if (utils.types.has(region, 'offset')) {
                const offset = region.offset;
                options.maxUpOffset = offset.top;
                options.maxDownOffset = offset.bottom;
                options.maxLeftOffset = offset.left;
                options.maxRightOffset = offset.right;
            }
            region = utils.geometry.round(utils.geometry.padding(region.region, (_a = region.padding) !== null && _a !== void 0 ? _a : 0));
        }
        return { left: region.x, top: region.y, width: region.width, height: region.height, ...options };
    }).sort((region1, region2) => {
        if (region1.top !== region2.top)
            return region1.top > region2.top ? 1 : -1;
        else if (region1.left !== region2.left)
            return region1.left > region2.left ? 1 : -1;
        else
            return 0;
    }).reduce(transformDuplicatedRegionIds(), []);
    function transformDuplicatedRegionIds() {
        const stats = {};
        return (regions, region, index) => {
            if (!region.regionId)
                return regions.concat(region);
            if (!stats[region.regionId]) {
                stats[region.regionId] = { firstIndex: index, count: 1 };
                return regions.concat(region);
            }
            const stat = stats[region.regionId];
            if (stat.count === 1) {
                regions[stat.firstIndex] = { ...regions[stat.firstIndex], regionId: `${region.regionId} (${stat.count})` };
            }
            stat.count += 1;
            return regions.concat({ ...region, regionId: `${region.regionId} (${stat.count})` });
        };
    }
}
