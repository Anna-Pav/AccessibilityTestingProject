import { type Logger } from '@applitools/logger';
import { type Transport } from './transport';
import * as transports from './transports';
export type WaitOptions = {
    timeout: number;
};
export interface Socket<TSocket = unknown> {
    readonly ready: boolean;
    readonly target: TSocket;
    use(socket: TSocket): void;
    cleanup(): void;
    emit(type: string | {
        name: string;
        key: string;
    }, payload?: Record<string, any>): () => void;
    on(type: string | {
        name: string;
        key: string;
    }, fn: (payload?: any, key?: string) => any): () => void;
    once(type: string | {
        name: string;
        key: string;
    }, fn: (payload?: any, key?: string) => any): () => void;
    off(type: string | {
        name: string;
        key: string;
    }, fn: (payload?: any, key?: string) => any): boolean;
    request(name: string, payload?: any): Promise<any>;
    command(name: string, fn: (payload?: any) => any): () => void;
    wait(name: string, options?: WaitOptions): PromiseLike<void>;
    wait<TResult>(name: string, fn: (payload?: any) => TResult, options?: WaitOptions): PromiseLike<TResult>;
}
export interface SocketOptions<TTransport extends keyof typeof transports | Transport<unknown>> {
    transport: TTransport;
    logger?: Logger;
}
export declare function makeSocket<TTransport extends keyof typeof transports | Transport<unknown>, TSocket extends TTransport extends keyof typeof transports ? (typeof transports)[TTransport] extends Transport<infer USocket> ? USocket : never : TTransport extends Transport<infer USocket> ? USocket : never>(target: TSocket, options: SocketOptions<TTransport>): Socket<TSocket>;
