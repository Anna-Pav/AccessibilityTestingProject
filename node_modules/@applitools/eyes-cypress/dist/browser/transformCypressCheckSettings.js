"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.transformCypressCheckSettings = void 0;
const utils = __importStar(require("@applitools/utils"));
const utils_1 = require("./utils");
function transformCypressCheckSettings(settings, refer) {
    if (utils.types.isString(settings)) {
        return { name: settings };
    }
    const target = settings.target === 'region' ? transformTargetRegion(settings) : undefined;
    return {
        renderers: (0, utils_1.transformBrowsers)(settings.browser),
        hooks: settings.scriptHooks,
        disableBrowserFetching: settings.disableBrowserFetching,
        layoutBreakpoints: settings.layoutBreakpoints,
        ufgOptions: settings.visualGridOptions,
        name: settings.tag,
        ignoreRegions: transformRegionsWithOptions(settings.ignore),
        floatingRegions: convertFloatingRegion(settings.floating),
        strictRegions: transformRegionsWithOptions(settings.strict),
        contentRegions: transformRegionsWithOptions(settings.content),
        layoutRegions: transformRegionsWithOptions(settings.layout),
        accessibilityRegions: convertAccessabilityRegions(settings.accessibility),
        userCommandId: settings.variationGroupId,
        region: utils.types.has(target, 'region') ? target.region : undefined,
        ignoreCaret: settings.ignoreCaret,
        ignoreDisplacements: settings.ignoreDisplacements,
        fully: settings.fully,
        waitBeforeCapture: settings.waitBeforeCapture,
        lazyLoad: settings.lazyLoad,
        matchLevel: settings.matchLevel,
        useDom: settings.useDom,
        sendDom: settings.sendDom,
        enablePatterns: settings.enablePatterns,
        pageId: settings.pageId,
    };
    function transformTargetRegion(checkSettings) {
        const shadowDomSettings = {};
        let regionSettings = {};
        if (!Array.isArray(checkSettings.selector)) {
            if (utils.types.has(checkSettings, 'element')) {
                if (isHTMLElement(checkSettings.element)) {
                    regionSettings = {
                        region: Object.assign(refer.ref(checkSettings.element), { type: 'element' }),
                    };
                }
                else if (utils.types.has(checkSettings.element, [0])) {
                    regionSettings = {
                        region: Object.assign(refer.ref(checkSettings.element[0]), { type: 'element' }),
                    };
                }
            }
            else if (utils.types.has(checkSettings, 'region') &&
                utils.types.has(checkSettings.region, 'top') &&
                utils.types.has(checkSettings.region, 'left') &&
                utils.types.has(checkSettings.region, 'width') &&
                utils.types.has(checkSettings.region, 'height')) {
                regionSettings = {
                    region: {
                        y: checkSettings.region.top,
                        x: checkSettings.region.left,
                        width: checkSettings.region.width,
                        height: checkSettings.region.height,
                    },
                };
            }
            else if (!utils.types.has(checkSettings, 'selector')) {
                regionSettings = {
                    region: checkSettings.region,
                };
            }
            else {
                regionSettings = {
                    region: checkSettings.selector,
                };
            }
        }
        else {
            const selectors = checkSettings.selector;
            for (let i = selectors.length - 1; i > -1; i--) {
                if (i === selectors.length - 1) {
                    shadowDomSettings['shadow'] = selectors[i].selector;
                }
                else {
                    const prevSettings = Object.assign({}, shadowDomSettings);
                    shadowDomSettings['selector'] = selectors[i].selector;
                    if (!prevSettings.hasOwnProperty('selector')) {
                        shadowDomSettings['shadow'] = prevSettings.shadow;
                    }
                    else {
                        shadowDomSettings['shadow'] = prevSettings;
                    }
                }
            }
            regionSettings = { region: shadowDomSettings };
        }
        return regionSettings;
    }
    function convertAccessabilityRegions(accessibilityRegions) {
        if (!accessibilityRegions)
            return;
        if (!Array.isArray(accessibilityRegions)) {
            accessibilityRegions = [accessibilityRegions];
        }
        const accessibility = [];
        for (const region of accessibilityRegions) {
            const accessabilityRegion = {
                type: utils.types.has(region, 'accessibilityType') ? region.accessibilityType : undefined,
            };
            if (utils.types.has(region, 'selector')) {
                const currRegion = { ...accessabilityRegion, region: region.selector };
                delete region.selector;
                accessibility.push(currRegion);
            }
            else if (utils.types.has(region, 'element')) {
                const elements = refElements(region.element);
                delete region['element'];
                for (const element of elements) {
                    accessibility.push(Object.assign({}, region, accessabilityRegion, { region: element }));
                }
            }
            else if (utils.types.has(region, 'region')) {
                const currRegion = { ...region, type: region.region.accessibilityType };
                delete currRegion.region.accessibilityType;
                accessibility.push(currRegion);
            }
            else if (utils.types.has(region, 'top')) {
                accessibility.push({
                    ...accessabilityRegion,
                    region: { y: region.top, x: region.left, width: region.width, height: region.height },
                });
            }
            else {
                accessibility.push(region);
            }
        }
        return accessibility;
    }
    function convertFloatingRegion(floatingRegions) {
        if (!floatingRegions)
            return;
        if (!Array.isArray(floatingRegions)) {
            floatingRegions = [floatingRegions];
        }
        const floating = [];
        for (const region of floatingRegions) {
            const floatingRegion = {
                offset: {
                    bottom: region.maxDownOffset || 0,
                    left: region.maxLeftOffset || 0,
                    top: region.maxUpOffset || 0,
                    right: region.maxRightOffset || 0,
                },
            };
            delete region.maxDownOffset;
            delete region.maxLeftOffset;
            delete region.maxUpOffset;
            delete region.maxRightOffset;
            if (utils.types.has(region, 'selector')) {
                const currRegion = { region: region.selector, ...region, ...floatingRegion };
                delete currRegion.selector;
                floating.push(currRegion);
            }
            else if (utils.types.has(region, 'element')) {
                const elements = refElements(region.element);
                delete region.element;
                for (const element of elements) {
                    floating.push({ ...region, ...floatingRegion, region: element });
                }
            }
            else if (utils.types.has(region, 'region')) {
                const currRegion = { offset: floatingRegion.offset, ...region };
                floating.push(currRegion);
            }
            else if (utils.types.has(region, 'top')) {
                floating.push({
                    ...floatingRegion,
                    region: {
                        y: region.top,
                        x: region.left,
                        width: region.width,
                        height: region.height,
                    },
                });
            }
            else {
                floating.push(region);
            }
        }
        return floating;
    }
    function transformRegionsWithOptions(regions) {
        if (!regions)
            return;
        if (!Array.isArray(regions))
            regions = [regions];
        let resRegions = [];
        for (const region of regions) {
            if (utils.types.has(region, 'element')) {
                if (utils.types.has(region, 'padding') || utils.types.has(region, 'regionId')) {
                    const currRefElements = refElements(region.element);
                    for (const refElement of currRefElements) {
                        const curr = { region: refElement };
                        if (region.padding) {
                            curr.padding = region.padding;
                        }
                        if (region.regionId) {
                            curr.regionId = region.regionId;
                        }
                        resRegions.push(curr);
                    }
                }
                else {
                    resRegions = [...resRegions, ...refElements(region.element)];
                }
            }
            else if (isHTMLElement(region) || utils.types.has(region, 'jquery')) {
                resRegions = [...resRegions, ...refElements(region)];
            }
            else {
                if (utils.types.has(region, 'selector') && !utils.types.has(region, 'type')) {
                    const currRegion = { region: region.selector, ...region };
                    delete currRegion.selector;
                    resRegions.push(currRegion);
                }
                else {
                    resRegions.push(region);
                }
            }
        }
        return resRegions;
    }
    function refElements(regions) {
        if (!regions)
            return;
        if (!Array.isArray(regions))
            regions = [regions];
        const elements = [];
        for (const region of regions) {
            if (isHTMLElement(region)) {
                elements.push(Object.assign(refer.ref(region), { type: 'element' }));
            }
            else if (utils.types.has(region, 'jquery')) {
                region.each(function () {
                    elements.push(isHTMLElement(this) ? Object.assign(refer.ref(this), { type: 'element' }) : this);
                });
            }
            else {
                elements.push(region);
            }
        }
        return elements;
    }
    function isHTMLElement(element) {
        return utils.types.has(element, 'nodeType') && element.nodeType === Node.ELEMENT_NODE;
    }
}
exports.transformCypressCheckSettings = transformCypressCheckSettings;
